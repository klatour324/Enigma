# enigma

## Self Assessment:

Enigma presented many triumphs and challenges in a short period of time. Where I think the bigger picture really came together for me was in the refactoring phase towards the end of the project. Per the rubric, I believe I performed as follows:

**Functionality:** 3 **Meets Expectations:** Enigma class with encrypt and decrypt methods successfully implemented. Encrypt/decrypt command line interfaces successfully implemented.

**Object Oriented Programming:** 3 **Meets Expectations:** This was a category that from the start I had difficulty figuring out how to implement the different functionalities, and actually made notes of my struggles of tackling inheritance then using modules throughout my pull request comment history. What helped me toward the end as it all came together was to see that my project worked best with modules as opposed to inheritance because there was not a lot of state being shared. While I did try refactoring based on inheritance, it did not prove to be better overall for properly demonstrating its use. Instead, I found it more beneficial to break out a couple of modules in this project for organizational purposes and to remove any redundancy within `Enigma`. In addition, after a few failures and roadblocks with how to proceed forward, I decided to incorporate two separate classes for `Key` and `Offset`. These classes were introduced after realizing inheritance would not allow me to inherit both classes into `Enigma` and `Enigma` did depend on each one of their states, but those two concepts could live independently. Creating these class objects that were then required into `Enigma` allowed me to use utilize each class when needed, for example, when creating `shifts` in my `make_shifts` method for `Enigma`, without creating this Parent/Child dependency relationship. It all kind of came back to the idea of a "is-a" relationship for me, and I could not justify any reason for a `Key` or `Offset` and their properties as a "is-a Enigma" relationship. To me, these classes seemed more like an `Enigma` *has-a* `Key` or `Offset`.

**Ruby Conventions & Mechanics:** 3 **Meet Expectations**: Overall, I did my best to keep proper indentation, consistency with syntax, lines to a good length, and all methods 10 lines and under. Of course, I think I can improve more on the syntax side of things and with more practice and helpful tools like Hound CI, I can track overtime with projects where I need help syntactically. Naming, too, with the methods and variables could use improvement. As for enumerable methods, I decided to use `each_with_index` and `reduce` for the main logic portion of the project because `each_with_index` allowed for me to not only iterate over each letter in `secret message`, it also gave me access to the index at which that character was located in my constant `ALPHABET`. This was an important key for determining which `shift` would be used per character and for determining rotations of `ALPHABET`. I also felt `reduce` was a useful enumerable here because it allowed me to initially pass in a string value, which I could then build up with the new characters after they have gone through the ciphering process. I am eager to see where I could improve and what would be a more efficient way of creating the encrypted code, as I think, while functioning, my implementation of the `create_code` method may be too verbose.

**Test Driven Development:** 4 **Above Expectations**: I really worked hard here to make sure that I was testing everything that I possibly could. Helper methods are tested and I implemented two stubs, one for the date, and also for random generation of a key when one is not given. When the `Key` object was used in `Enigma`, I made sure to test that given any instance of `Key`, if no key is given it would stub the `rand` method and just return a key value that I had expected from my test. Overall, SimpleCov is showing 100% test coverage. I made sure to implement tests first before writing the code. I think even with this score, there is room for improvement here with testing for more edge cases, writing more robust tests, and other best practices for TDD.

**Version Control**: A minimum of 30 commits and pull request workflow have been made to meet the version control requirements for a passing project.  
